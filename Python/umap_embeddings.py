import numpy as np
import matplotlib.pyplot as plt

from umap import UMAP
from scipy.io import loadmat, savemat
from sklearn.metrics import silhouette_samples
from matplotlib.lines import Line2D
from matplotlib.gridspec import GridSpecFromSubplotSpec

from dependencies import data_path, figure_path
from helper_functions import load_data, generate_colors, plot_config


def create_umap_vs_nneighbors(
    ephys_data,
    names,
    metric="correlation",
    n_reps=10,
    embed_dim=2,
    n_neighbors_vals=np.round(np.logspace(np.log10(5), np.log10(500), 10) / 5).astype(int) * 5
):
    """
    Generate the given number of UMAP embeddings for each of the given numbers of nearest neighbors

    Parameters
    ----------
    ephys_data : list
        Dictionaries containing the processed neural activity and neuron locations
    names : list 
        Names of mice
    metric : str, default="correlation"
        Distance measure
    n_reps : int, default=10
        Number of embeddings to generate for each number of nearest neighbors
    embed_dim : int, default=2
        Embedding dimension
    n_neighbor_vals : array-like
        Array of values of number of nearest neighbors

    """

    embed_dict = dict()
    embed_dict["n_neighbor_vals"] = n_neighbors_vals
    embed_dict["embed_dim"] = embed_dim

    for imouse, dat in enumerate(ephys_data):
        print(names[imouse] + ':', end='\t')
        spkmat = dat["spkmat"]
        embeddings = np.zeros((n_neighbors_vals.size, spkmat.shape[0], embed_dim*n_reps))
        for i, nn in enumerate(n_neighbors_vals):
            print(nn, end=' ')
            for j in range(n_reps):
                embeddings[i, :, j*embed_dim:(j+1)*embed_dim] = UMAP(n_neighbors=nn, n_components=embed_dim, metric=metric).fit_transform(spkmat)

        embed_dict[names[imouse]] = embeddings
        print()
 
    savemat(f"{data_path}/umap_embeddings.mat", mdict=embed_dict)


def plot_umap_vs_nneighbors(
    ephys_data,
    names,
    region_colors,
    n_plots=5,
    plot_size=(4, 4)
):
    """
    Plot the UMAP embeddings generated by the create_umap_vs_nneighbors function

    Parameters
    ----------
    ephys_data : list
        Dictionaries containing the processed neural activity and neuron locations
    names : list 
        Names of mice
    region_colors : list
        List of colors assigned to brain regions
    n_plots : int, default=5
        Number of plots for each mouse/row
    plot_size : float, default=(4, 4)
        Width and height of indidividual plots
    """

    # load saved UMAP embeddings
    embed_dict = loadmat(f"{data_path}/umap_embeddings.mat")
    embed_dim = embed_dict["embed_dim"].item()
    n_neighbor_vals = embed_dict["n_neighbor_vals"].flatten()
   
    reglbs = ephys_data[0]["reglbs"]
    i_emb = 0
    
    # initialize and adjust axes
    nrows, ncols = len(names), n_plots
    width, height = plot_size
    fig, axs = plt.subplots(nrows, ncols, figsize=(ncols*width, nrows*height))
    fig.subplots_adjust(wspace=0.1, hspace=0.15)

    # main
    for irow, row, ephys, name in zip(list(range(len(names))), axs, ephys_data, names):
        regIDs = ephys["regIDs"]
        cols = [region_colors[rid-1] for rid in regIDs]
        embed_imouse = embed_dict[name]
        for icol, ax, embed, nn in zip(list(range(n_neighbor_vals.size)), row, embed_imouse[::2], n_neighbor_vals[::2]):
            sils = silhouette_samples(embed[:, i_emb*embed_dim:(i_emb+1)*embed_dim], regIDs)
            ax.scatter(embed[:, 0], embed[:, 1], c=cols, s=6)
            ax.set_xticks([])
            ax.set_yticks([])
            ax.set_title((f"n_neighbors={nn}\n\n" if irow==0 else "") + f"s={sils.mean():.4f}", y=0.98)
            if icol==0:
                ax.set_ylabel(name, labelpad=60, rotation=0, ha="center")

    ax.set_xlabel("UMAP 1")
    ax.set_ylabel("UMAP 2")
    ax.get_yaxis().set_label_position("right")
    
    h = [Line2D(
        [0], [0],
        marker='o',
        markerfacecolor=cl,
        color='w',
        markersize=16,
        label=lb,
    ) for cl, lb in zip(region_colors, reglbs)]

    fig.legend(
        handles=h,
        ncol=1,
        handletextpad=0.1,
        prop={"size":16},
        bbox_to_anchor=(1.02, 0.89),
        framealpha=0
    )

    plt.savefig(f"{figure_path}/umap_vs_nn.png", bbox_inches="tight")

def plot_silhouette_vs_nneighbors(
    ephys_data,
    names,
    mice_colors
):
    """
    Plot mean Silhouette standard deviation of UMAP embeddings versus the number of nearest neighbors.
    For each neuron, the standard deviation of Silhouette coefficients is computed
    across UMAP embebdings with the same number of nearest neighbors
    (saved results of the create_umap_vs_nneighbors are required)

    Parameters
    ----------
    ephys_data : list
        Dictionaries containing the processed neural activity and neuron locations
    names : list 
        Names of mice
    mice_colors : list
        List of colors assigned to mice

    """

    # load saved UMAP embeddings
    embed_dict = loadmat(f"{data_path}/umap_embeddings.mat")
    embed_dim = embed_dict["embed_dim"].item()
    n_neighbor_vals = embed_dict["n_neighbor_vals"].flatten()

    # initialize axes
    fig, ax = plt.subplots(figsize=(15, 5))

    # main
    for name, ephys, color in zip(names, ephys_data, mice_colors):
        regIDs = ephys["regIDs"]
        embed_imouse = embed_dict[name]
        
        # calculate the standard deviation of Silhouette coefficients
        # across UMAP embeddings for each neuron then
        # the mean of those standard deviations 
        sil_mean_stds = np.zeros(n_neighbor_vals.size)
        for inn, embed_nn in enumerate(embed_imouse):
            sil_samples = np.array([
                silhouette_samples(
                    X=embed_nn[:, i*embed_dim:(i+1)*embed_dim],
                    labels=regIDs,
                    metric="euclidean"
                    )
                for i in range(n_neighbor_vals.size)])

            sil_mean_stds[inn] = sil_samples.std(axis=0).mean()

        ax.plot(n_neighbor_vals, sil_mean_stds, color=color, label=name)

    ax.set_ylim((0, 0.15))
    ax.set_yticks(np.arange(0, 0.16, 0.05))
    ax.set_ylabel(r"$E[\sigma_{s(i)}]$")
    ax.set_xlabel("Number of nearest neighbors")
    ax.legend(
        loc="upper right",
        prop=dict(size=15),
        framealpha=0
    )

    plt.savefig( f"{figure_path}/silhouette_vs_nn.png", bbox_inches="tight", transparent=True)